#include "cache.h"
#include <string.h>

#include "BOP/direct_map_RR_table.h"
#include "BOP/full_associative_RR_table.h"
#include "BOP/RR_table.h"
#include "BOP/offset_scoreboard.h"

#define STARTING_D 1
#define RR_TABLE_ADDR_WIDTH 8

#define TABLE_OFFSET_WIDTH 12

#define SCOREMAX 31
#define ROUNDMAX 100
#define BADSCORE 1

// #define ASSOCIATIVE

#ifdef ASSOCIATIVE
    FullyAssociativeRRTable<RR_TABLE_ADDR_WIDTH, 3> RR_table;
#else
    DirectMapRRTable<RR_TABLE_ADDR_WIDTH> RR_table;
#endif

OffsetScoreboard offset_scoreboard(SCOREMAX, BADSCORE);

uint64_t D;
uint64_t current_round;
uint64_t current_offset_idx;

bool same_page(uint64_t cur_addr, uint64_t pref_addr){
    uint64_t addr_page = cur_addr >> LOG2_PAGE_SIZE;
    uint64_t pref_page = pref_addr >> LOG2_PAGE_SIZE;

    return addr_page == pref_page;
}

void CACHE::l2c_prefetcher_initialize() 
{
    cout << "CPU " << cpu << " L2C next line prefetcher" << endl;

    D = STARTING_D;

    current_round = 1;
    current_offset_idx = 0;
    offset_scoreboard.reset_scores();
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in)
{
    uint64_t X = addr;
    uint64_t XD = X + D;

    DP ( if (warmup_complete[cpu]) {
        cout << "[" << NAME << "] " << __func__ << hex << " base_cl: " << (addr>>LOG2_BLOCK_SIZE);
        cout << " pf_cl: " << (XD>>LOG2_BLOCK_SIZE) << " ip: " << ip << " cache_hit: " << +cache_hit << " type: " << +type << endl; 
    });

    if (!cache_hit || /*prefetch hit*/0)
    {
        if (same_page(X, XD))
        {
            prefetch_line(ip, addr, X + D, FILL_L2, 0);
            
            //cout << "prefetched" << endl;

            if (true)//prefetch) 
            {
                uint64_t Y = addr;
                uint64_t YD = Y-D;
                /*
                uint64_t page_table_mask = ~((1U << RR_TABLE_ADDR_WIDTH) - 1);
                if ((Y & page_table_mask) == (YD & page_table_mask))
                {
                    RR_table.insert(YD);
                }
                */
                if ((Y>>TABLE_OFFSET_WIDTH) == (YD>>TABLE_OFFSET_WIDTH))
                {
                    RR_table.insert(YD);
                }
            }
            // cout << "prefetching. D = " << D << endl;
        }
    }

    // Update score of current offset
    if (RR_table.exists(X - offset_scoreboard.POTENTIAL_OFFSETS[current_offset_idx]))
    {
        bool score_too_high = offset_scoreboard.inc_score(current_offset_idx);
        if (score_too_high)
        {
            // SCOREMAX has been surpassed. End round, move to next phase.
            uint64_t best_offset;

            bool score_too_low = offset_scoreboard.get_best_offset(best_offset);
            D = (score_too_low) ?  0 : best_offset;

            cout << "(79) new D = " << D << endl;

            offset_scoreboard.reset_scores();
            current_round = 1;
            current_offset_idx = 0;
        }
    }

    // Move to next offset, next round, or next phase
    current_offset_idx++;
    // cout << "current_offset_idx " << current_offset_idx << " | " << offset_scoreboard.NUM_OFFSETS << endl;
    if (current_offset_idx >= offset_scoreboard.NUM_OFFSETS)
    {
        current_offset_idx = 0;
        current_round++;

        if(current_round >= ROUNDMAX)
        {
            uint64_t best_offset;
            
            bool score_too_low = offset_scoreboard.get_best_offset(best_offset);

            D = (score_too_low) ?  0 : best_offset;

            cout << "(100) new D = " << D << endl;

            offset_scoreboard.reset_scores();
            current_round = 1;
        }
    }

    return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
/**
 * Pseudocode:
 *  If receive data from L3 and data was prefetched then
 *      let y = addr of data
 *      If Y and Y-D like in the same page then
 *          store Y-D in RR table
 *      end
 *  end
 */
{
    // the TA didn't use this
    // if (prefetch) 
    // {
    //     uint64_t Y = addr;
    //     uint64_t YD = Y-D;
    //     /*
    //     uint64_t page_table_mask = ~((1U << RR_TABLE_ADDR_WIDTH) - 1);
    //     if ((Y & page_table_mask) == (YD & page_table_mask))
    //     {
    //         RR_table.insert(YD);
    //     }
    //     */
    //     if ((Y>>TABLE_OFFSET_WIDTH) == (YD>>TABLE_OFFSET_WIDTH))
    //     {
    //         RR_table.insert(YD);
    //     }
    // }
    return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L2C next line prefetcher final stats" << endl;
}

/*

start phase (cache operate)
    for round_i in Learning Phase:
        for d_i in potential offsets
            wait for next cache access
            let X = addr of access
            if x-d_i is in RR then
                increment d_i.score
                if d_i score is SCORE_MAX then
                    update D to d_i
                    set all d_i score to 0
                    GOTO start phase
                end
            end
        end
        if round_i is ROUND_MAX then:
            if the best score is not greater than BAD_SCORE then
                set D to 0
            else
                set D to max(d_i)
            end
            set all d_i score to 0
        end
    end

prefetching (cache operate)
    if received req. for x in K2 then
        if miss or prefetch hit then
            if x and x+D is same page then
                prefetch X+D
            end
        end
    end

*/

/*
RR_table

load data in

check if something is in table

*/